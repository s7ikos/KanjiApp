## Содержание
- [Установка и тестовые данные](#установка-и-тестовые-данных)
- [Идея создания](#идея-создания)
- [Стек технологий](#стек-технологий)
- [Entities](#entities-сущности)
- [База данных](#база-данных)
- [Контроллер](#контроллер)
- [Интерфейс: Qt и PySide6](#интерфейс-qt-и-pyside6)
- [Стилизация через QSS](#стилизация-через-qss)
- [Интерфейс](#интерфейс)
- [Перспективы развития](#перспективы-развития)
- [Зачем это всё?](#зачем-это-всё)
---
# Установка и тестовые данные

### Запуск приложения:
- Дважды кликните `run_app.bat`
- Файл автоматически проверит и установит необходимые зависимости
- Приложение откроется после успешной проверки

### Добавление тестовых данных:
- Дважды кликните `setup.bat`  
- Файл установит зависимости если нужно и добавит тестовые данные
- После выполнения запустите `run_app.bat`

---
# Как я создавал это приложение, какой опыт получил и зачем оно вообще нужно

Возможно, эта статья станет для кого-то туториалом, кого-то вдохновит попробовать сделать что-то подобное, а кто-то
просто начнёт пользоваться этим приложением.
---
## Идея создания

Изначально я хотел создать pet-проект для своего портфолио программиста. При этом мне хотелось сделать что-то
действительно полезное и практичное (привет всем, кто писал очередной todo-лист!).

В интернете полно идей для таких проектов. Но недавно я начал изучать японский язык, и в голову пришла мысль совместить
эти два занятия. Существуют приложения и сайты — например, Anki или Jisho.org, — где можно посмотреть значения кандзи или слов, учить их или просто получить справочную информацию. Однако мне не хватало одной ключевой возможности: **я не мог легко выстраивать связи между кандзи**.

Да, на Jisho.org есть ссылки по радикалам, но только внутри самих иероглифов. Если вы ищете слово, вы не можете сразу
перейти к отдельным кандзи и посмотреть их значения. А ведь именно так часто и приходится запоминать:

```
日 — день  
今 — настоящее время, сейчас  
毎 — каждый...

毎日 — каждый день  
今日 — сегодня
```

Некоторые слова интуитивно понятны **по написанию** (именно по написанию, а не по чтению). Поэтому мне захотелось иметь возможность переходить от слова сразу к составляющим его кандзи. А в случае сложных иероглифов — переходить к их радикалам и компонентам.

Именно это и подтолкнуло меня к созданию данного приложения. Сначала оно задумывалось исключительно для личного пользования, но в итоге получилось достаточно удобно и аккуратно — возможно, оно пригодится и другим.

Я не эксперт в UX/UI и не фронтендер-профессионал, но логика приложения работает именно так, как я и задумывал. Так что результатом я доволен.

---

## Стек технологий


Проект написан полностью на **Python** — я хотел сделать его максимально доступным для понимания и доработки даже тем,
кто не специализируется на десктопной разработке.

Основные компоненты стека:

- **PySide6** — официальная Python-привязка к фреймворку Qt. Выбрал именно её, потому что она активно поддерживается, имеет отличную документацию и не требует лицензирования для open-source проектов. Плюс — вся логика интерфейса остаётся на Python, без необходимости писать QML или использовать C++.

- **SQLite** — встраиваемая реляционная база данных. Идеально подходит для локального приложения: не нужно настраивать сервер, данные хранятся в одном файле, а запросы выполняются быстро даже при тысячах записей. Для моих задач (карточки кандзи и словарь) это более чем достаточно.

- **Типизация через `typing`** — использовал аннотации типов (`List`, `Optional`, `NamedTuple`), чтобы уменьшить количество ошибок и сделать код читабельнее. Особенно полезно при работе с сущностями вроде `Kanji` и `Word`.

- **Чистая архитектура** — логика разнесена по слоям:  
  - `entities.py` — данные,  
  - `database.py` — работа с БД (CRUD),  
  - `controller.py` — бизнес-логика и сборка связанных объектов,  
  - `main.py` — только интерфейс и навигация.  

Это позволило легко тестировать отдельные части и не запутаться при расширении функционала.

- **QSS (Qt Style Sheets)** — для стилизации интерфейса. Вместо встроенных тем Qt я написал собственную тёмную тему, ориентированную на комфорт при длительной работе с иероглифами. Все стили вынесены в отдельный файл — так проще поддерживать и менять внешний вид.

---
## Entities (Сущности)

Прежде всего нужно определить, с какими объектами мы будем работать, и создать их.

```python
# entities.py

from typing import List
from collections import namedtuple

# Новый тип для представления радикала и его варианта в составе сложного кандзи — для читаемости
KanjiComponent = namedtuple('KanjiComponent', ['kanji', 'variant_form'])

class Kanji:
    def __init__(self, id=None, character="", meaning="", on_readings="",
                 kun_readings="", jlpt_level=None, is_complex=False, notes=""):
        self.id = id                                # ID для базы данных
        self.character = character                  # Сам символ кандзи (иероглиф)
        self.meaning = meaning                      # Значение кандзи
        self.on_readings = on_readings              # Чтение онъёми (on'yomi)
        self.kun_readings = kun_readings            # Чтение кунъёми (kun'yomi)
        self.jlpt_level = jlpt_level                # Уровень JLPT (N5–N1)
        self.is_complex = is_complex                # Является ли иероглиф составным
        self.notes = notes                          # Поле для заметок
        self.radicals: List[KanjiComponent] = []    # Список радикалов (компонентов)
        self.variations: List[str] = []             # Варианты написания как радикала
```

С первыми пятью полями всё понятно. Уровень JLPT не всегда указан на сторонних ресурсах — так что это полезный бонус.
Поле `notes` пригодится для ассоциаций, мнемоник или любой другой полезной информации, которая помогает запомнить кандзи.

Список `radicals` нужен, чтобы в составных иероглифах можно было переходить к их компонентам. А список `variations` —
это своего рода обратная связь: он показывает, в каком виде данный кандзи может выступать как радикал в других 
иероглифах. Это особенно полезно для запоминания, потому что форма радикала иногда отличается от его самостоятельного
написания.

Также нам понадобится сущность «слово». Тут всё довольно прозрачно:

```python
# entities.py

class Word:
    def __init__(self, id=None, japanese="", reading="", translation="", notes=""):
        self.id = id                                # ID для базы данных
        self.japanese = japanese                    # Написание слова иероглифами/кана
        self.reading = reading                      # Чтение слова (фуригана)
        self.translation = translation              # Перевод
        self.notes = notes                          # Поле для заметок
        self.kanji_vocabulary: List[Kanji] = []     # Список кандзи, из которых состоит слово
```

---

## База данных
Выбор пал на SQLite — встраиваемую базу данных, не требующую отдельного сервера и хранящую всё содержимое в одном файле.
Это решение идеально подходит для небольших проектов, где важна простота развёртывания и отсутствует необходимость в
сложной распределённой архитектуре.

### Структура базы данных  
После анализа предметной области выяснилось, что для полноценной работы достаточно пяти таблиц:  
- `kanji` — основная информация о кандзи: символ, значение, чтения, уровень JLPT;  
- `vocabulary` — японские слова с переводом и чтением;  
- `vocabulary_kanji` — связь «многие-ко-многим» между словами и кандзи, из которых они состоят;  
- `kanji_components` — компоненты (радикалы) сложных кандзи, реализованные через самосвязь таблицы `kanji`;  
- `kanji_variants` — альтернативные формы написания кандзи, особенно в роли радикалов внутри других иероглифов.

Для соблюдения принципа **разделения ответственности** вся работа с базой вынесена в отдельный менеджер:

```python
# database.py

class DatabaseManager:
    def __init__(self, db_name: str = "kanji.db"):
        self.db_name = db_name

    def initialize_database(self) -> None:
        # Создание всех таблиц с внешними ключами
        with sqlite3.connect(self.db_name) as conn:
            conn.execute("PRAGMA foreign_keys = ON")
            
            # Таблица слов
            conn.execute('''
                CREATE TABLE IF NOT EXISTS vocabulary (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    japanese TEXT NOT NULL,
                    reading TEXT NOT NULL,
                    translation TEXT NOT NULL,
                    notes TEXT DEFAULT ''
                )
            ''')
            
            # Таблица связи кандзи с радикалами
            conn.execute('''
                CREATE TABLE IF NOT EXISTS kanji_components (
                    kanji_id INTEGER NOT NULL,
                    component_id INTEGER NOT NULL,
                    PRIMARY KEY (kanji_id, component_id),
                    FOREIGN KEY (kanji_id) REFERENCES kanji(id) ON DELETE CASCADE,
                    FOREIGN KEY (component_id) REFERENCES kanji(id) ON DELETE CASCADE
                )
            ''')
```

Для каждой таблицы реализованы стандартные CRUD-операции. Например метод search_kanji_basic позволяет искать кандзи по 
нескольким критериям одновременно. Он проверяет, совпадает ли запрос с самим символом кандзи, входит ли он в значение,
он-чтение или кун-чтение (даже частично), а если запрос — число, то сравнивает его с уровнем JLPT. Такой подход делает
поиск гибким: достаточно ввести часть значения (например, «вода») или чтение на фуригане (например, «суй»), и поиск 
покажет все совпадения.

```python
def search_kanji_basic(self, query: str) -> List[Kanji]:
    """
    Выполняет базовый поиск кандзи по различным полям.

    Ищет совпадения в:
    - точном совпадении символа
    - частичном совпадении в значении
    - частичном совпадении в он-чтениях
    - частичном совпадении в кун-чтениях
    - уровне JLPT (если запрос число)

    Args:
        query: Строка поискового запроса.

    Returns:
        Список объектов Kanji, удовлетворяющих запросу.
    """
    with sqlite3.connect(self.db_name) as conn:
        cursor = conn.cursor()
        cursor.execute('''
            SELECT * FROM kanji
            WHERE character = ? 
               OR meaning LIKE ? 
               OR on_readings LIKE ? 
               OR kun_readings LIKE ?
               OR jlpt_level = ?
        ''', (query, f"%{query}%", f"%{query}%", f"%{query}%",
              query if query.isdigit() else -1))

        results = []
        for row in cursor.fetchall():
            kanji = Kanji(
                id=row[0], character=row[1], meaning=row[2],
                on_readings=row[3], kun_readings=row[4],
                jlpt_level=row[5], is_complex=bool(row[6]), notes=row[7]
            )
            results.append(kanji)
        return results
```
---

## Контроллер
Сложные операции, затрагивающие несколько таблиц, вынесены в отдельный контроллер. Он отвечает за сборку полной карточки кандзи или слова — именно той информации, которую видит пользователь.

Например, чтобы получить полную информацию о кандзи (включая варианты написания и компоненты), контроллер последовательно выполняет несколько запросов:

```python
def get_kanji_info(self, kanji_id: int) -> Optional[Kanji]:
    """
    Получить полную информацию о кандзи.
    Собирает данные из нескольких таблиц.
    """
    # 1. Получаем базовую информацию о кандзи
    kanji = self.db_manager.get_kanji_by_id(kanji_id)
    if not kanji:
        return None

    # 2. Получаем варианты написания
    variants = self.db_manager.get_kanji_variants(kanji_id)
    kanji.variations = variants

    # 3. Если кандзи сложный, получаем компоненты
    if kanji.is_complex:
        components = self.db_manager.get_kanji_components(kanji_id)
        # Преобразуем в KanjiComponent объекты
        for component in components:
            # Получаем вариант написания для этого компонента в контексте текущего кандзи
            component_variants = self.db_manager.get_kanji_variants(component.id)
            variant_form = component_variants[0] if component_variants else None

            component_info = KanjiComponent(kanji=component, variant_form=variant_form)
            kanji.radicals.append(component_info)

    return kanji
```
Такой подход позволяет сохранить код чистым и поддерживаемым, разделяя ответственность между простыми операциями с БД и
сложной бизнес-логикой.

---

## Интерфейс: Qt и PySide6

В качестве фреймворка для GUI я выбрал **PySide6**. Это мощное и кроссплатформенное решение, которое отлично подходит
как для прототипирования, так и для создания полноценных десктопных приложений.
Весь интерфейс построен по принципу **стека страниц** (`QStackedWidget`). Это позволяет легко управлять навигацией: 
пользователь переходит от стартовой страницы к поиску, от поиска — к карточке слова или кандзи,
от карточки — к редактированию, и так далее. При нажатии «Назад» текущая страница удаляется из стека,
и отображается предыдущая. Такой подход исключает необходимость в сложной маршрутизации и делает логику переходов прозрачной.

Каждая страница — это отдельный класс-наследник `QWidget`:  
- `StartPage` — приветственный экран с двумя кнопками;  
- `SearchPage` — поле поиска и список результатов;  
- `CardPage` — детальная карточка кандзи или слова с возможностью перехода по связям;  
- `AddItemPage` и `EditItemPage` — формы для создания и редактирования записей.

Особое внимание уделено **навигации по связям**. В карточке кандзи компоненты отображаются как кликабельные ссылки,
а в карточке слова — все входящие в него кандзи. При клике на любой из них приложение загружает соответствующую карточку
и добавляет её в стек. Это создаёт ощущение «путешествия» по графу знаний — именно то, чего мне не хватало в других
инструментах.

Также реализована возможность **редактировать и удалять** любую запись прямо из карточки. Все изменения сразу сохраняются в базу, а интерфейс обновляется без перезагрузки.

---
## Стилизация через QSS

Qt поддерживает собственный аналог CSS — **Qt Style Sheets (QSS)**. Весь внешний вид вынесен в отдельный файл `styles.qss`. Это позволило полностью отделить логику от представления и быстро экспериментировать с цветовой схемой.

Я выбрал **тёмную тему** — она лучше всего подходит для длительной работы с текстом и иероглифами. Цвета подобраны так, чтобы крупные символы кандзи читались максимально комфортно, а интерактивные элементы (ссылки, кнопки) были заметны, но не раздражающе яркими.

В стилях активно используются **псевдоклассы** (`:hover`, `:pressed`) и **кастомные CSS-классы** через `setProperty("class", "...")`. Это дало гибкость: например, все заголовки имеют класс `title`, а кликабельные кандзи — класс `clickable`. Такой подход гораздо удобнее, чем задавать стили inline или через objectName для каждого элемента.

Вот фрагмент из `styles.qss`, отвечающий за карточки:

```css
QLabel[class="main_character"] {
    font-size: 60px;
    font-weight: bold;
    color: #FFFFFF;
    text-align: center;
    margin: 10px 0;
}

QLabel[class="clickable"] {
    color: #87CEEB;
    text-decoration: underline;
    font-size: 16px;
}
```

Благодаря этому даже без глубоких знаний в дизайне удалось добиться аккуратного и функционального вида.

---


## Интерфейс

Главный экран выглядит следующим образом — достаточно минималистично :) Отсюда можно перейти либо к поиску, либо создать новую карточку: слово или кандзи.

<div align="center">
    <img src="images/Главный экран.png" alt="Главный экран" width="500">
</div>

Окно поиска тоже максимально простое. В принципе, всё в этом приложении сделано так, чтобы можно было сразу начать пользоваться — без долгого разбирательства в интерфейсе.

<div align="center">
    <img src="images/Окно поиска.png" alt="Окно поиска" width="500">
</div>

Вот, например, результат по запросу «а» (да, я очень оригинальный):

<div align="center">
    <img src="images/Пример поиска.png" alt="Пример запроса" width="500">
</div>

Удобно, что уже на превью видно: это слово или кандзи, как оно пишется и что означает. Не нужно кликать, чтобы понять, то ли это, что вы искали.

Если же нужна более детальная информация — можно просто кликнуть и перейти в карточку. Слева — пример карточки кандзи, справа — карточки слова:

<div align="center">
    <img src="images/Пример карточки.png" alt="Карточка кандзи" width="500">
    <img src="images/Карточка слова.png" alt="Карточка слова" width="500">
</div>

Обратите внимание на кликабельные ссылки: в карточке слова — это входящие кандзи, в карточке кандзи — его компоненты.
По ним можно переходить глубже, строя ассоциативные цепочки.

Если что-то нужно поправить — например, вы ошиблись при вводе или захотели дополнить заметками — всегда можно отредактировать запись:

<div align="center">
    <img src="images/Экран редактирования.png" alt="Экран редактирования" width="500">
</div>

Страница создания устроена точно так же, только поля изначально пустые.

---
## Перспективы развития

Я думал над тем как можно в дальнейшем развивать приложение и вот что пришло в голову:
- Добавить для скачивания пресеты по уровням JLPT, чтобы можно было сразу скачать и изучать
- Добавить визуализацию для связей. В моем идеальном мире это выглядет как большой граф в котором все кандзи взаимосвязаны
- Режим изучения как в анки. Чтобы можно было заходить не только заносить, а еще и изучать. Но думаю это логичнее сделать 
как раз после пресетов
---
## Зачем это всё?

Когда я начинал думать над идеей для pet-проекта я думал что будет какой то очередной проходняк, который просто будет лежать
бесполезным кодом в моем гите, но в голову пришла идея объединить 2 дела и сделать то что мне самому реально нужно.
Мне важно не просто заучивать кандзи, а видеть связи между ними.
Именно так мозг лучше запоминает: через структуру, а не через изолированные факты.

Приложение получилось простым, но функциональным. Оно не пытается заменить Anki или Jisho — оно дополняет их.
Здесь я могу быстро найти слово, сразу увидеть, из каких кандзи оно состоит, перейти к любому из них, посмотреть,
из чего он сам состоит, и так далее — как по веткам дерева.

Если вы тоже учитесь японскому и хотите не просто зубрить, а **понимать**, как устроены иероглифы — возможно,
этот инструмент окажется вам полезен. А если нет — надеюсь, хотя бы вдохновит на создание своего.
Исходный код открыт. Pull request’ы, идеи и просто «спасибо» — всегда в радость :)
